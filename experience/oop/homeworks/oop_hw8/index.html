<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>dongje kim
|
HW8
</title><meta charset=utf-8><meta name=generator content="Hugo 0.120.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="dongje kim"><meta name=description content="Portfolio"><link rel=stylesheet href=/dongje.kim/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/dongje.kim/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/dongje.kim/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/dongje.kim/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/dongje.kim/favicon-16x16.png><link rel=canonical href=https://dk3156.github.io/dongje.kim/experience/oop/homeworks/oop_hw8/><script type=text/javascript src=/dongje.kim/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script><script type=text/javascript src=/dongje.kim/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="HW8"><meta name=twitter:description content="Answers Polynomial.cpp // // hw08.cpp // hw08 // // Created by DJ on 5/1/22. // #include &#34;polynomial.h&#34; #include <iostream> #include <vector> using namespace std; ostream& operator<<(ostream& os, const Polynomial& rhs){ Polynomial::Node* rhs_ptr = rhs.head_ptr; size_t degree = rhs.degree; while(rhs_ptr != nullptr){ int data = rhs_ptr->data; if(data != 0){ if(degree == 0){ os << data; } else if (degree == 1){ if(data == 1){ os << &#34;x + &#34;; } else if (data == -1){ os << &#34;-x + &#34;; } else { os << data << &#34;x + &#34;; } } else { if (data == 1){ os << &#34;x^&#34; << degree << &#34; + &#34;; } else if (data == -1){ os << &#34;-x^&#34; << degree << &#34; + &#34;; } else { os << data << &#34;x^&#34; << degree << &#34; + &#34;; } } } --degree; rhs_ptr = rhs_ptr->next; } return os; } Polynomial::Polynomial(): degree(0){ head_ptr = new Node(); } Polynomial::Polynomial(vector<int> coeff){ head_ptr = new Node(coeff[0]); Node* cur = head_ptr; for(size_t i = 1; i < coeff."><meta property="og:title" content="HW8"><meta property="og:description" content="Answers Polynomial.cpp // // hw08.cpp // hw08 // // Created by DJ on 5/1/22. // #include &#34;polynomial.h&#34; #include <iostream> #include <vector> using namespace std; ostream& operator<<(ostream& os, const Polynomial& rhs){ Polynomial::Node* rhs_ptr = rhs.head_ptr; size_t degree = rhs.degree; while(rhs_ptr != nullptr){ int data = rhs_ptr->data; if(data != 0){ if(degree == 0){ os << data; } else if (degree == 1){ if(data == 1){ os << &#34;x + &#34;; } else if (data == -1){ os << &#34;-x + &#34;; } else { os << data << &#34;x + &#34;; } } else { if (data == 1){ os << &#34;x^&#34; << degree << &#34; + &#34;; } else if (data == -1){ os << &#34;-x^&#34; << degree << &#34; + &#34;; } else { os << data << &#34;x^&#34; << degree << &#34; + &#34;; } } } --degree; rhs_ptr = rhs_ptr->next; } return os; } Polynomial::Polynomial(): degree(0){ head_ptr = new Node(); } Polynomial::Polynomial(vector<int> coeff){ head_ptr = new Node(coeff[0]); Node* cur = head_ptr; for(size_t i = 1; i < coeff."><meta property="og:type" content="article"><meta property="og:url" content="https://dk3156.github.io/dongje.kim/experience/oop/homeworks/oop_hw8/"><meta property="article:section" content="experience"><meta property="og:site_name" content="Dongje Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"experience","name":"HW8","headline":"HW8","alternativeHeadline":"","description":"
      
        Answers Polynomial.cpp \/\/ \/\/ hw08.cpp \/\/ hw08 \/\/ \/\/ Created by DJ on 5\/1\/22. \/\/ #include \u0026#34;polynomial.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Polynomial\u0026amp; rhs){ Polynomial::Node* rhs_ptr = rhs.head_ptr; size_t degree = rhs.degree; while(rhs_ptr != nullptr){ int data = rhs_ptr-\u0026gt;data; if(data != 0){ if(degree == 0){ os \u0026lt;\u0026lt; data; } else if (degree == 1){ if(data == 1){ os \u0026lt;\u0026lt; \u0026#34;x \u002b \u0026#34;; } else if (data == -1){ os \u0026lt;\u0026lt; \u0026#34;-x \u002b \u0026#34;; } else { os \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#34;x \u002b \u0026#34;; } } else { if (data == 1){ os \u0026lt;\u0026lt; \u0026#34;x^\u0026#34; \u0026lt;\u0026lt; degree \u0026lt;\u0026lt; \u0026#34; \u002b \u0026#34;; } else if (data == -1){ os \u0026lt;\u0026lt; \u0026#34;-x^\u0026#34; \u0026lt;\u0026lt; degree \u0026lt;\u0026lt; \u0026#34; \u002b \u0026#34;; } else { os \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#34;x^\u0026#34; \u0026lt;\u0026lt; degree \u0026lt;\u0026lt; \u0026#34; \u002b \u0026#34;; } } } --degree; rhs_ptr = rhs_ptr-\u0026gt;next; } return os; } Polynomial::Polynomial(): degree(0){ head_ptr = new Node(); } Polynomial::Polynomial(vector\u0026lt;int\u0026gt; coeff){ head_ptr = new Node(coeff[0]); Node* cur = head_ptr; for(size_t i = 1; i \u0026lt; coeff.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/dk3156.github.io\/dongje.kim\/experience\/oop\/homeworks\/oop_hw8\/"},"author":{"@type":"Person","name":"dongje kim"},"creator":{"@type":"Person","name":"dongje kim"},"accountablePerson":{"@type":"Person","name":"dongje kim"},"copyrightHolder":{"@type":"Person","name":"dongje kim"},"copyrightYear":"0001","dateCreated":"0001-01-01T00:00:00.00Z","datePublished":"0001-01-01T00:00:00.00Z","dateModified":"0001-01-01T00:00:00.00Z","publisher":{"@type":"Organization","name":"dongje kim","url":"https://dk3156.github.io/dongje.kim/","logo":{"@type":"ImageObject","url":"https:\/\/dk3156.github.io\/dongje.kim\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/dk3156.github.io\/dongje.kim\/experience\/oop\/homeworks\/oop_hw8\/","wordCount":"1066","genre":[],"keywords":[]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/dongje.kim/images/tiger.png alt="profile picture"><div class=sidebar__introduction-title><a href=/dongje.kim>Dongje Kim</a></div><div class=sidebar__introduction-description><p>Portfolio</p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/dongje.kim/ title>Home</a></li><li class=nav__list-item><a href=/dongje.kim/experience/work/ title>experience</a></li><li class=nav__list-item><a href=/dongje.kim/projects/ title>project</a></li><li class=nav__list-item><a href=/dongje.kim/blog/ title>blog</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>HW8</h1><h2 id=answers>Answers</h2><h2 id=polynomialcpp>Polynomial.cpp</h2><pre tabindex=0><code>//
//  hw08.cpp
//  hw08
//
//  Created by DJ on 5/1/22.
//
#include &#34;polynomial.h&#34;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
    
ostream&amp; operator&lt;&lt;(ostream&amp; os, const Polynomial&amp; rhs){
    Polynomial::Node* rhs_ptr = rhs.head_ptr;
    size_t degree = rhs.degree;
    while(rhs_ptr != nullptr){
        int data = rhs_ptr-&gt;data;
        if(data != 0){
            if(degree == 0){
                os &lt;&lt; data;
            } else if (degree == 1){
                if(data == 1){
                    os &lt;&lt; &#34;x + &#34;;
                } else if (data == -1){
                    os &lt;&lt; &#34;-x + &#34;;
                }
                else {
                    os &lt;&lt; data &lt;&lt; &#34;x + &#34;;
                }
            } else {
                if (data == 1){
                    os &lt;&lt; &#34;x^&#34; &lt;&lt; degree &lt;&lt; &#34; + &#34;;
                } else if (data == -1){
                    os &lt;&lt; &#34;-x^&#34; &lt;&lt; degree &lt;&lt; &#34; + &#34;;
                } else {
                    os &lt;&lt; data &lt;&lt; &#34;x^&#34; &lt;&lt; degree &lt;&lt; &#34; + &#34;;
                }
            }
        }
        --degree;
        rhs_ptr = rhs_ptr-&gt;next;
    }
    return os;
}

Polynomial::Polynomial(): degree(0){
    head_ptr = new Node();
}

Polynomial::Polynomial(vector&lt;int&gt; coeff){
    head_ptr = new Node(coeff[0]);
    Node* cur = head_ptr;
    for(size_t i = 1; i &lt; coeff.size(); ++i){
        cur-&gt;next = new Node(coeff[i]);
        cur = cur-&gt;next;
    }
    degree = coeff.size() - 1;
    clean();
}

Polynomial::Polynomial(const Polynomial&amp; rhs): degree(rhs.degree){
    head_ptr = new Node(rhs.head_ptr-&gt;data);
    Node* this_cur = head_ptr;
    Node* rhs_cur = rhs.head_ptr-&gt;next;
    while(rhs_cur != nullptr){
        this_cur-&gt;next = new Node(rhs_cur-&gt;data);
        this_cur = this_cur-&gt;next;
        rhs_cur = rhs_cur-&gt;next;
    }
}

Polynomial::~Polynomial(){
    Node* cur = head_ptr;
    while(cur != nullptr){
        Node* cur2 = cur-&gt;next;
        delete cur;
        cur = cur2;
    }
}

int Polynomial::evaluate(int value){}


Polynomial&amp; Polynomial::operator+=(const Polynomial&amp; rhs){
    size_t this_degree = degree;
    size_t rhs_degree = rhs.degree;
    Node* this_cur = head_ptr;
    Node* rhs_cur = rhs.head_ptr;
    if(degree &gt; rhs.degree){
        while(this_degree != rhs_degree){
            this_cur = this_cur-&gt;next;
            --this_degree;
        }
    } else if (degree &lt; rhs.degree){
        degree = rhs.degree;
        head_ptr = new Node(rhs.head_ptr-&gt;data);
        Node* this_cur2 = head_ptr;
        rhs_cur = rhs.head_ptr;
        while(this_degree != rhs_degree){
            this_cur2-&gt;next = new Node(rhs_cur-&gt;next-&gt;data);
            rhs_cur = rhs_cur-&gt;next;
            this_cur2 = this_cur2-&gt;next;
            --rhs_degree;
        }
    }
    while(this_cur != nullptr){
        this_cur-&gt;data += rhs_cur-&gt;data;
        this_cur = this_cur-&gt;next;
        rhs_cur = rhs_cur-&gt;next;
    }
    return *this;
}

bool operator==(const Polynomial&amp; lhs, const Polynomial&amp; rhs){
    if (lhs.degree != rhs.degree){
        return false;
    }
    Polynomial::Node* lhs_ptr = lhs.head_ptr;
    Polynomial::Node* rhs_ptr = rhs.head_ptr;
    while (lhs_ptr != nullptr){
        if(lhs_ptr-&gt;data != rhs_ptr-&gt;data){
            return false;
        }
        lhs_ptr = lhs_ptr-&gt;next;
        rhs_ptr = rhs_ptr-&gt;next;
    }
    return true;
}

Polynomial&amp; Polynomial::operator=(const Polynomial&amp; rhs){
    if (this != &amp;rhs){
        Node* cur = head_ptr;
        while(cur != nullptr){
            Node* cur2 = cur-&gt;next;
            delete cur;
            cur = cur2;
        }
        degree = rhs.degree;
        head_ptr = rhs.head_ptr;
        Node* lhs_ptr = head_ptr;
        Node* rhs_ptr = rhs.head_ptr-&gt;next;
        while(rhs_ptr != nullptr){
            lhs_ptr-&gt;next = new Node(lhs_ptr-&gt;data);
            lhs_ptr = lhs_ptr-&gt;next;
            rhs_ptr = rhs_ptr-&gt;next;
        }
    }
    return *this;
}

void Polynomial::clean(){
    Node* cur = head_ptr;
    bool flag = true;
    while(cur-&gt;next != nullptr &amp;&amp; flag){
        if (cur-&gt;data == 0){
            head_ptr = cur-&gt;next;
            delete cur;
            cur = head_ptr;
            --degree;
        } else {
            flag = false;
        }
    }
}


Polynomial operator+(const Polynomial&amp; lhs, const Polynomial&amp; rhs){
    Polynomial result = lhs;
    result += rhs;
    return result;
}


bool operator!=(const Polynomial&amp; lhs, const Polynomial&amp; rhs){
    return !(lhs == rhs);
}
</code></pre><h2 id=polynomialh>Polynomial.h</h2><pre tabindex=0><code>
#ifndef polynomial_h
#define polynomial_h
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class Polynomial{
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Polynomial&amp; rhs);
    friend bool operator==(const Polynomial&amp; lhs, const Polynomial&amp; rhs);
    
public:
    struct Node{
        Node(int data = 0, Node* next = nullptr): data(data), next(next){}
        int data;
        Node* next;
    };
    Polynomial();
    Polynomial(vector&lt;int&gt; coeffs);
    Polynomial(const Polynomial&amp; rhs);
    Polynomial&amp; operator=(const Polynomial&amp; rhs);
    ~Polynomial();
    Polynomial&amp; operator+=(const Polynomial&amp; rhs);
    void clean();
    int evaluate(int value);
    
private:
    Node* head_ptr;
    size_t degree;
};

Polynomial operator+(const Polynomial&amp; lhs, const Polynomial&amp; rhs);
bool operator!=(const Polynomial&amp; lhs, const Polynomial&amp; rhs);
    

#endif /* polynomial_h */
</code></pre><h2 id=testpolynomialcpp>testPolynomial.cpp</h2><pre tabindex=0><code>/*
  testPolynomial.cpp
  Test code for the Polynomial class
 */

#include &#34;polynomial.h&#34;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void doNothing(Polynomial temp) {}

int main() {
        
    //test constructor
    Polynomial p1({17});                 // 17
    Polynomial p2({1, 2});               // x + 2
    Polynomial p3({-1, 5});              // -x + 5
    Polynomial p4({5, 4, 3, 2, 1});      // 5x^4 + 4x^3 + 3x^2 + 2x + 1
    Polynomial has_a_zero({4, 0, 1, 7}); // 4x^3 + x + 7

    // Polynomial temp(p4);
    // cout &lt;&lt; &#34;temp: &#34; &lt;&lt; temp &lt;&lt; endl;
        
    //    cerr &lt;&lt; &#34;displaying polynomials\n&#34;;
    cout &lt;&lt; &#34;p1: &#34; &lt;&lt; p1 &lt;&lt; endl;
    cout &lt;&lt; &#34;p2: &#34; &lt;&lt; p2 &lt;&lt; endl;
    cout &lt;&lt; &#34;p3: &#34; &lt;&lt; p3 &lt;&lt; endl;
    cout &lt;&lt; &#34;p4: &#34; &lt;&lt; p4 &lt;&lt; endl;
    cout &lt;&lt; &#34;has_a_zero: &#34; &lt;&lt; has_a_zero &lt;&lt; endl;

    // Polynomial temp;
    // temp = p2 + p3;
    // cout &lt;&lt; &#34;temp: &#34; &lt;&lt; temp &lt;&lt; endl;
    
    cout &lt;&lt; &#34;p2 + p3: &#34; &lt;&lt; (p2+p3) &lt;&lt; endl; 
    cout &lt;&lt; &#34;p2 + p4: &#34; &lt;&lt; (p2+p4) &lt;&lt; endl; 
    cout &lt;&lt; &#34;p4 + p2: &#34; &lt;&lt; (p4+p2) &lt;&lt; endl;

    //test copy constructor - the statement below uses the copy constructor
    //to initialize poly3 with the same values as poly4
    Polynomial p5(p4);
    p5 += p3;
    cout &lt;&lt; &#34;Polynomial p5(p4);\n&#34;
         &lt;&lt; &#34;p5 += p3;\n&#34;;

    cout &lt;&lt; &#34;p4: &#34; &lt;&lt; p4 &lt;&lt; endl;  
    cout &lt;&lt; &#34;p5: &#34; &lt;&lt; p5 &lt;&lt; endl;  


    cout &lt;&lt; &#34;Calling doNothing(p5)\n&#34;;
    doNothing(p5);
    cout &lt;&lt; &#34;p5: &#34; &lt;&lt; p5 &lt;&lt; endl;

    //tests the assignment operator
    Polynomial p6;
    cout &lt;&lt; &#34;p6: &#34; &lt;&lt; p6 &lt;&lt; endl;
    cout &lt;&lt; boolalpha;  // Causes bools true and false to be printed that way.
    cout &lt;&lt; &#34;(p4 == p6) is &#34; &lt;&lt; (p4 == p6) &lt;&lt; endl;
    p6 = p4;
    cout &lt;&lt; &#34;p6: &#34; &lt;&lt; p6 &lt;&lt; endl;
    cout &lt;&lt; boolalpha;
    cout &lt;&lt; &#34;(p4 == p6) is &#34; &lt;&lt; (p4 == p6) &lt;&lt; endl;

    //test the evaluaton
    int x = 5;
//    cout &lt;&lt; &#34;Evaluating p1 at &#34; &lt;&lt; x &lt;&lt; &#34; yields: &#34; &lt;&lt; p1.evaluate(5) &lt;&lt; endl;
//    cout &lt;&lt; &#34;Evaluating p2 at &#34; &lt;&lt; x &lt;&lt; &#34; yields: &#34; &lt;&lt; p2.evaluate(5) &lt;&lt; endl;
//        
//    Polynomial p7({3, 2, 1});           // 3x^2 + 2x + 1
//    cout &lt;&lt; &#34;p7: &#34; &lt;&lt; p7 &lt;&lt; endl;
//    cout &lt;&lt; &#34;Evaluating p7 at &#34; &lt;&lt; x &lt;&lt; &#34; yields: &#34; &lt;&lt; p7.evaluate(5) &lt;&lt; endl;

    cout &lt;&lt; boolalpha;
    cout &lt;&lt; &#34;(p1 == p2) is &#34; &lt;&lt; (p1 == p2) &lt;&lt; endl;
    cout &lt;&lt; &#34;(p1 != p2) is &#34; &lt;&lt; (p1 != p2) &lt;&lt; endl;

    Polynomial p8({ 1, 1 });
    Polynomial p9({ -1, 1 });
    Polynomial p10({ 0, 0, 2 });
    //p8 + p9 tests if += does the cleanup()
    //p10 tests if constructor does the cleanup()

    cout &lt;&lt; &#34;p8: &#34; &lt;&lt; p8 &lt;&lt; endl
         &lt;&lt; &#34;p9: &#34; &lt;&lt; p9 &lt;&lt; endl
         &lt;&lt; &#34;p10: &#34; &lt;&lt; p10 &lt;&lt; endl;

    cout &lt;&lt; &#34;((p8 + p9) == p10) is &#34; &lt;&lt; ((p8 + p9) == p10) &lt;&lt; endl;
}
</code></pre></div><div class=post__footer></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>