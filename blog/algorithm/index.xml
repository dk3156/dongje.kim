<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>알고리즘 on DONGJE KIM</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/</link><description>Recent content in 알고리즘 on DONGJE KIM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dk3156.github.io/dongje.kim/blog/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>구현 &amp; 계산</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/implement/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/implement/</guid><description>선분의 길이
https://school.programmers.co.kr/learn/courses/30/lessons/120876
class Solution { public int solution(int[][] lines) { // 1. arr 배열 및 변수 초기화 int[] arr = new int[200]; int answer = 0; // 2. lines 정보를 arr 배열에 적용 for(int i = 0; i &amp;lt; lines.length; i++) for(int j = lines[i][0] + 100; j &amp;lt; lines[i][1] + 100; j++) arr[j]++; // 3. arr 배열에서 겹친 부분 세기 for(int i = 0; i &amp;lt; 200; i++) if(arr[i] &amp;gt; 1) answer++; return answer; } } array 를 사용하기.</description></item><item><title>해쉬</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/hash/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/hash/</guid><description>Hash 문제 나왔을때 Sorting 하고 포문 도는 것과 비슷하게 빠를 때가 많으니 소팅을 잘하자!
hash -&amp;gt; 의상. 입지 않은 경우 None 을 넣어서 표현하기.
Iterator variable_name = iterating object(list, tuple…).iterator()
while (variable_name.hasNext()): → returns boolean variable_name.next() → returns next iterator variable_name.next().intValue() → returns next iterator’s int value 문제 해결 방법을 찾을때는 더 쉽게 쉽게 생각하고, 코딩을 실제로 하기 시작할때 빨리 생각하자. 처음 생각할때 복잡하게 생각할 필요가 없음.
프로그래머스 순위 검색 https://school.</description></item><item><title>Python</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/python/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/python/</guid><description>귀납 귀납 제한 풀기. python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.
&amp;gt;&amp;gt; sys.setrecursionlimit(100000) 우선순위큐 파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.
from queue import PriorityQueue que = PriorityQueue() a = 100 que.put(0 - a) print(0 - que.get()) → 100 import heapq lst = [] heapq.heappush(lst, 4) heapq.heappop(lst) lst[0] heapq.heapify(lst) 파이토닉 문법들 enumerate 으로 index, element 동시에 가져올 수 있다</description></item><item><title>완전탐색</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/brute/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/brute/</guid><description>Brute Force, 완전탐색 https://www.youtube.com/watch?v=9aHVA7mJcqQ 참고. 모든 경우의 수를 전부 탐색하는것. 세가지 종류가 있다
포문 : for 문으로 모든 경우의 수를 본다. for 문의 개수는 임의로 정해도 되고 재귀를 서서 조건이 만족할 때까지 불러도 된다. 1초 제한 문제(코테) 에는 먹히지 않는다. for(int i=0; i&amp;lt;n; i++) for(int j= i + 1; j &amp;lt; n; j++) sum = arr[i] + arr[j]; 재귀 : 백트래킹이라고도 하며, 재귀가 끝나고 특정 조건을 다시 원위치시키는 것을 말한다. 다시 말하면 조건을 만족시키지 못한 경우의 수를 버리고 다시 parent recursion call 로 돌아간다는 것.</description></item></channel></rss>