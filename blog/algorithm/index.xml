<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>알고리즘 on DONGJE KIM</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/</link><description>Recent content in 알고리즘 on DONGJE KIM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dk3156.github.io/dongje.kim/blog/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Python</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/codingtest/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/codingtest/</guid><description>귀납 귀납 제한 풀기. python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.
&amp;gt;&amp;gt; sys.setrecursionlimit(100000) 우선순위큐 파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.
from queue import PriorityQueue que = PriorityQueue() a = 100 que.put(0 - a) print(0 - que.get()) → 100 import heapq lst = [] heapq.heappush(lst, 4) heapq.heappop(lst) lst[0] heapq.heapify(lst)</description></item><item><title>완전탐색</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/brute/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/brute/</guid><description>Brute Force, 완전탐색 https://www.youtube.com/watch?v=9aHVA7mJcqQ 참고. 모든 경우의 수를 전부 탐색하는것. 세가지 종류가 있다
포문 : for 문으로 모든 경우의 수를 본다. for 문의 개수는 임의로 정해도 되고 재귀를 서서 조건이 만족할 때까지 불러도 된다. 1초 제한 문제(코테) 에는 먹히지 않는다. for(int i=0; i&amp;lt;n; i++) for(int j= i + 1; j &amp;lt; n; j++) sum = arr[i] + arr[j]; 재귀 : 백트래킹이라고도 하며, 재귀가 끝나고 특정 조건을 다시 원위치시키는 것을 말한다. 다시 말하면 조건을 만족시키지 못한 경우의 수를 버리고 다시 parent recursion call 로 돌아간다는 것.</description></item></channel></rss>