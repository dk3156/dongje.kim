<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>알고리즘 on DONGJE KIM</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/</link><description>Recent content in 알고리즘 on DONGJE KIM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dk3156.github.io/dongje.kim/blog/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Kruskal</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/mst/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/mst/</guid><description>최소 신장 트리를 찾는 크루스칼 알고리즘 크루스칼 알고리즘이란 최소 신장 트리를 찾는 알고리즘으로, 원본 그래프에소 신장 트리를 만들 수 있는 경우의 수들 둥 최소의 간선 비용을 들여서 만들 수 있는 신장트리를 최소 신장 트리라고 한다. 크루스칼 알고리즘은 가장 적은 간선 비용으로 모든 노드를 연결할 수 있는데, 이런 측면에서 그리디 알고리즘으로 분류되기도 한다. 크루스칼 알고리즘의 동작 과정을 단계화시키면 다음과 같다.
주어진 모든 간선 정보에 대해 간선 비용이 낮은 순서(오름차순)로 정렬을 수행 정렬된 간선 정보를 하나씩 확인 하면서 현재의 간선이 노드들 간의 사이클을 발생시키는지 확인 만약 사이클이 발생하지 않은 경우, 최소 신장 트리에 포함시키고 사이클이 발생한 경우, 최소 신장 트리에 포함시키지 않음 1번~3번의 과정을 모든 간선 정보에 대해 반복 수행 위 단계를 살펴보면 노드들 간의 사이클이 발생하는지 여부에 따라 최소 신장 트리로 포함시킬지 여부를 결정하는 것을 볼 수 있다.</description></item><item><title>데이터베이스</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/database/</link><pubDate>Mon, 13 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/database/</guid><description>인덱스란? 데이터 베이스 테이블에서 특정원소를 찾을때 더 빨리 찾기 위해 임시로 지정해주는 숫자. 테이블의 컬럼마다 인덱스를 지정해준다. 원소 a 를 찾을때 완전탐색으로 일일히 찾는것이 아니라 a 와 관련된 인덱스를 찾고 그 인덱스가 가르키는 주소 (테이블에서 a가 들어있는 행) 을 리턴해준다. 인덱스와 관련된 컬럼은 정렬이 되어있기 때문에 binary search 로 더 빠르게 찾을 수 있다. 실제 데이터베이스 구조로는 bst 뿐만아니라 b tree, b+ tree 를 쓰는데 이는 bst 를 개선한 트리로 b tree 는 세갈래로 나누어지는 구조이고 b+ 트리는 leaf 노드 부분에 데이터를 저장, 그 위 노드들은 데이터를 어디서 찾아햐 하는지 알려주는 명령어가 담겨있다.</description></item><item><title>구현 &amp; 계산</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/implement/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/implement/</guid><description>선분의 길이
https://school.programmers.co.kr/learn/courses/30/lessons/120876
class Solution { public int solution(int[][] lines) { // 1. arr 배열 및 변수 초기화 int[] arr = new int[200]; int answer = 0; // 2. lines 정보를 arr 배열에 적용 for(int i = 0; i &amp;lt; lines.length; i++) for(int j = lines[i][0] + 100; j &amp;lt; lines[i][1] + 100; j++) arr[j]++; // 3. arr 배열에서 겹친 부분 세기 for(int i = 0; i &amp;lt; 200; i++) if(arr[i] &amp;gt; 1) answer++; return answer; } } array 를 사용하기.</description></item><item><title>해쉬</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/hash/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/hash/</guid><description>Hash 문제 나왔을때 Sorting 하고 포문 도는 것과 비슷하게 빠를 때가 많으니 소팅을 잘하자!
hash -&amp;gt; 의상. 입지 않은 경우 None 을 넣어서 표현하기.
Iterator variable_name = iterating object(list, tuple…).iterator()
while (variable_name.hasNext()): → returns boolean variable_name.next() → returns next iterator variable_name.next().intValue() → returns next iterator’s int value 문제 해결 방법을 찾을때는 더 쉽게 쉽게 생각하고, 코딩을 실제로 하기 시작할때 빨리 생각하자. 처음 생각할때 복잡하게 생각할 필요가 없음.
프로그래머스 순위 검색 https://school.</description></item><item><title>Python</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/python/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/python/</guid><description>귀납 귀납 제한 풀기. python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.
&amp;gt;&amp;gt; sys.setrecursionlimit(100000) 우선순위큐 파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.
from queue import PriorityQueue que = PriorityQueue() a = 100 que.put(0 - a) print(0 - que.get()) → 100 import heapq lst = [] heapq.heappush(lst, 4) heapq.heappop(lst) lst[0] heapq.heapify(lst) 파이토닉한 문법들 enumerate 으로 index, element 동시에 가져올 수 있다</description></item><item><title>완전탐색</title><link>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/brute/</link><pubDate>Sun, 05 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/brute/</guid><description>Brute Force, 완전탐색 https://www.youtube.com/watch?v=9aHVA7mJcqQ 참고. 모든 경우의 수를 전부 탐색하는것. 세가지 종류가 있다
포문 : for 문으로 모든 경우의 수를 본다. for 문의 개수는 임의로 정해도 되고 재귀를 서서 조건이 만족할 때까지 불러도 된다. 1초 제한 문제(코테) 에는 먹히지 않는다. for(int i=0; i&amp;lt;n; i++) for(int j= i + 1; j &amp;lt; n; j++) sum = arr[i] + arr[j]; 재귀 : 백트래킹이라고도 하며, 재귀가 끝나고 특정 조건을 다시 원위치시키는 것을 말한다. 다시 말하면 조건을 만족시키지 못한 경우의 수를 버리고 다시 parent recursion call 로 돌아간다는 것.</description></item></channel></rss>