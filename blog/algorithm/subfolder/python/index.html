<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>dongje kim
|
Python
</title><meta charset=utf-8><meta name=generator content="Hugo 0.121.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="dongje kim"><meta name=description content="Portfolio"><link rel=stylesheet href=/dongje.kim/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/dongje.kim/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/dongje.kim/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/dongje.kim/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/dongje.kim/favicon-16x16.png><link rel=canonical href=https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/python/><script type=text/javascript src=/dongje.kim/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script><script type=text/javascript src=/dongje.kim/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Python"><meta name=twitter:description content="귀납 귀납 제한 풀기. python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.
>> sys.setrecursionlimit(100000) 우선순위큐 파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.
from queue import PriorityQueue que = PriorityQueue() a = 100 que.put(0 - a) print(0 - que.get()) → 100 import heapq lst = [] heapq.heappush(lst, 4) heapq.heappop(lst) lst[0] heapq.heapify(lst) 파이토닉한 문법들 enumerate 으로 index, element 동시에 가져올 수 있다"><meta property="og:title" content="Python"><meta property="og:description" content="귀납 귀납 제한 풀기. python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.
>> sys.setrecursionlimit(100000) 우선순위큐 파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.
from queue import PriorityQueue que = PriorityQueue() a = 100 que.put(0 - a) print(0 - que.get()) → 100 import heapq lst = [] heapq.heappush(lst, 4) heapq.heappop(lst) lst[0] heapq.heapify(lst) 파이토닉한 문법들 enumerate 으로 index, element 동시에 가져올 수 있다"><meta property="og:type" content="article"><meta property="og:url" content="https://dk3156.github.io/dongje.kim/blog/algorithm/subfolder/python/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-11-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-05T00:00:00+00:00"><meta property="og:site_name" content="Dongje Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"Python","headline":"Python","alternativeHeadline":"","description":"
      
        귀납 귀납 제한 풀기. python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.\n\u0026gt;\u0026gt; sys.setrecursionlimit(100000) 우선순위큐 파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.\nfrom queue import PriorityQueue que = PriorityQueue() a = 100 que.put(0 - a) print(0 - que.get()) → 100 import heapq lst = [] heapq.heappush(lst, 4) heapq.heappop(lst) lst[0] heapq.heapify(lst) 파이토닉한 문법들 enumerate 으로 index, element 동시에 가져올 수 있다


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/dk3156.github.io\/dongje.kim\/blog\/algorithm\/subfolder\/python\/"},"author":{"@type":"Person","name":"dongje kim"},"creator":{"@type":"Person","name":"dongje kim"},"accountablePerson":{"@type":"Person","name":"dongje kim"},"copyrightHolder":{"@type":"Person","name":"dongje kim"},"copyrightYear":"2023","dateCreated":"2023-11-05T00:00:00.00Z","datePublished":"2023-11-05T00:00:00.00Z","dateModified":"2023-11-05T00:00:00.00Z","publisher":{"@type":"Organization","name":"dongje kim","url":"https://dk3156.github.io/dongje.kim/","logo":{"@type":"ImageObject","url":"https:\/\/dk3156.github.io\/dongje.kim\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/dk3156.github.io\/dongje.kim\/blog\/algorithm\/subfolder\/python\/","wordCount":"600","genre":[],"keywords":[]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/dongje.kim/images/tiger.png alt="profile picture"><div class=sidebar__introduction-title><a href=/dongje.kim>Dongje Kim</a></div><div class=sidebar__introduction-description><p>Portfolio</p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/dongje.kim/ title>Home</a></li><li class=nav__list-item><a href=/dongje.kim/experience/work/ title>experience</a></li><li class=nav__list-item><a href=/dongje.kim/projects/ title>project</a></li><li class=nav__list-item><a href=/dongje.kim/blog/ title>blog</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Python</h1><h2 id=귀납>귀납</h2><p>귀납 제한 풀기.
python 은 기본적으로 귀납 제한이 1000 이기 때문에, 귀납을 더 반복하고 싶으면 제한을 풀어줘야한다.</p><pre tabindex=0><code>&gt;&gt; sys.setrecursionlimit(100000)
</code></pre><h2 id=우선순위큐>우선순위큐</h2><p>파이썬은 min_heap 밖에 제공하지 않으므로, max_heap 을 구현하고 싶다면 원소를 음수로 바꿔 저장한 뒤, 꺼낼때 다시 양수로 바꾸면 된다.</p><pre tabindex=0><code>from queue import PriorityQueue
que = PriorityQueue()
a = 100
que.put(0 - a)
print(0 - que.get())
→ 100

import heapq

lst = []
heapq.heappush(lst, 4)
heapq.heappop(lst)
lst[0]
heapq.heapify(lst)
</code></pre><h2 id=파이토닉한-문법들>파이토닉한 문법들</h2><p>enumerate 으로 index, element 동시에 가져올 수 있다</p><pre tabindex=0><code>animals = [cat, dog, sheep]
for i, animal in enumerate(animals):
    print(i, animal)
</code></pre><p>file 열때 with 를 사용해 read, write를 구분해 준다.</p><pre tabindex=0><code>with open(&#39;spam&#39;.txt, w) as fileObj:
    fileObj.write(&#39;helloworld&#39;)
</code></pre><p>None 을 비교할때 == 말고 is 를 쓰면 예외처리가 가능하다.</p><pre tabindex=0><code>if spam is None:
    #do something
</code></pre><p>원시문자열 r 에서는 백슬래시를 이스케이프 문자로 취급하지 않으니 directory 주소를 원시문자열로 표현하자.</p><pre tabindex=0><code>print( r &#39;users\hashtag\something\myfolder\file.txt&#39;)
</code></pre><p>f-string</p><pre tabindex=0><code>width, length = 10, 12
print( f&#39; a{width} by {length} room has an area of {width * height})
</code></pre><p>copy 모듈에서 카피 메서드로 객체 복사를 해준다.</p><pre tabindex=0><code>import copy
lst = [a, b, c]
egg = copy.copy(lst)
</code></pre><p>Dictionary 메서드 중 get, setdefault 를 쓰면 if문을 제거하고 깔끔하게 해쉬를 업데이트 할 수 있다.</p><pre tabindex=0><code>num = {&#39;dog&#39; : 1}
&gt;&gt; num.get(&#39;cat&#39;, 0) #returns 0
&gt;&gt; num.setdefault(&#39;cat&#39;, 0) # does nothing if cat exists
&gt;&gt; num[cat] += 10
</code></pre><p>Switch 문 대신 dictionary 를 사용하자</p><pre tabindex=0><code>if season == &#34;winter&#34;:
    holiday = &#39;a&#39;
elif season == &#34;spring&#34;:
    holiday = &#39;b&#39;
else:
    holiday = &#39;c&#39;
...

holiday = {&#34;winter&#34; : &#39;a&#39;,
           &#34;spring&#34; : &#39;b&#39;,
            ...}.get(season, &#39;c&#39;)
</code></pre><p>체이닝 할당, 체이닝 연산자를 사용하자</p><pre tabindex=0><code>if 10 &lt; num &lt; 20:
    score = F

spam = egg = bacon = &#34;breakfast&#34;
print(spam, egg, bacon)

if(spam == egg == bacon):
    print(&#34;breakfast&#34;)
</code></pre><p>List Comprehension 으로 map, filter 를 대채할 수 있다.</p><pre tabindex=0><code>[n for n in [1,2,3,4] if n % 2 == 0]
</code></pre><h2 id=파이썬에서-순열-조합-모듈가져오기>파이썬에서 순열, 조합 모듈가져오기</h2><p>from itertools import permutations</p><p>from itertools import combinations</p><pre tabindex=0><code>from itertools import permutations

def getMax(lst1, lst2):
    total = 0
    for i in range(len(lst1)):
        total += i * (lst2[i] - lst1[i])
    return total
                
def solution2(arr1, arr2):
    sumOfPerm = []
    gen1 = permutations(arr1)
    gen2 = permutations(arr2)
        
    for perm1 in gen1:
        for perm2 in gen2:
            sumOfPerm.append(getMax(perm1, perm2))
            
    return max(sumOfPerm)

arr1 = [1,2,3,4]
arr2 = [1,2,3,4]
print(solution2(arr1, arr2))
</code></pre><h2 id=정렬>정렬</h2><p>함수를 사용해 배열 정렬을 하기 위해서는 functools 모듈의 functools.cmp_to_key() 메서드를 가져다가 쓰면된다.
sort 함수에 key 파라미터에 함수를 패스해준다.
sort 함수는 negative value, 0, positive value 셋 중 하나를 리턴해야 한다.
예를 들어 item1 , item2 를 비교할때 item1 &lt; item2 라면 마이너스 값을 리턴하고,
item1 > item2 라면 플러스 값을 리턴해 준다. 함수에서 비교한 더 작은 값을 정렬도중 앞으로 보내게 되어있다.
return item1 - item2 또한 같은 역할을 한다.</p><pre tabindex=0><code>import functools
def compare(item1, item2):
    global preferences
    preferred_item1 = 0
    preferred_item2 = 0
    for pref in preferences:
        if pref.index(item1) &lt; pref.index(item2):
            preferred_item1 += 1
        else:
            preferred_item2 += 1
        
    if preferred_item1 == preferred_item2:
        #smaller id beats larget id
        return item1 - item2
    elif preferred_item1 &gt; preferred_item2:
        #item1 beats item2
        return -1
    else:
        #item2 beats item 1
        return 1
        
def solution(preferences):
    n = len(preferences)
    m = len(preferences[0])

    songList = [x for x in range(m)]
    songList.sort(key=functools.cmp_to_key(compare))
    return songList

preferences = [[2, 1, 0], [0, 2, 1], [0, 2, 1]]
print(solution(preferences))
</code></pre><h3 id=lambda-key-를-이용한-정렬>lambda key 를 이용한 정렬</h3><p>프로그래머스 오답풀이:
<a href=https://school.programmers.co.kr/learn/courses/30/lessons/42579>https://school.programmers.co.kr/learn/courses/30/lessons/42579</a></p><p>lambda key x : criteria(x) 로 정렬을 할때, () 를 사용하면 두 가지 이상의 criteria 로 정렬을 할 수 있다.
(criteria1(x), criteria2(x), criteria3(x)) 형식으로 3개의 함수를 wrap 해서 lambda key 로 넘겨주면 3 가지 조건 전부 적용이 되서 정렬된다.</p><pre tabindex=0><code>temp = [[genres[i], plays[i], i] for i in range(len(genres))]   
temp = sorted(temp, key=lambda x: (x[0], -x[1], x[2]))  
</code></pre><p>dictionary.item() 으로 key, value pairs 를 동시에 정렬도 가능.</p><pre tabindex=0><code>total_genre_d = sorted(total_genre_d.items(), key = lambda x: -x[1]) 
</code></pre></div><div class=post__footer></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>