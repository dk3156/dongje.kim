<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>프로그래머스 on DONGJE KIM</title><link>https://dk3156.github.io/dongje.kim/blog/programmers/</link><description>Recent content in 프로그래머스 on DONGJE KIM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 31 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dk3156.github.io/dongje.kim/blog/programmers/index.xml" rel="self" type="application/rss+xml"/><item><title>그리디-큰 수 만들기</title><link>https://dk3156.github.io/dongje.kim/blog/programmers/subfolder/%ED%81%B0%EC%88%98%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/programmers/subfolder/%ED%81%B0%EC%88%98%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>https://school.programmers.co.kr/learn/courses/30/lessons/42883
완전탐색 (실패) k 개를 뺀 모든 숫자를 비교한 뒤 가장 큰 값을 리턴. 재귀 함수를 사용. 시간 초과로 실패.
def makeNum(num, j, k, maxNum): if j == k: return int(num) for i in range(len(num)): temp = num[:i] + num[i + 1:] maxNum = max(maxNum, makeNum(temp, j + 1, k, maxNum)) return maxNum def solution(number, k): return str(makeNum(number, 0, k, 0)) 스택 LIFO (성공) 핵심은 스택의 마지막 값이 push 할 값보다 작다면 크거나 같은 값이 나올 때까지 값들에 대해서 pop을 하는 것입니다.</description></item><item><title>leve3-베스트앨범</title><link>https://dk3156.github.io/dongje.kim/blog/programmers/subfolder/%EB%B2%A0%EC%8A%A4%ED%8A%B8-%EC%95%A8%EB%B2%94/</link><pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/programmers/subfolder/%EB%B2%A0%EC%8A%A4%ED%8A%B8-%EC%95%A8%EB%B2%94/</guid><description>https://school.programmers.co.kr/learn/courses/30/lessons/42579
나의 풀이 def solution(genres, plays): genreList = {} genreSum = {} bestAlbum = [] for i, genre in enumerate(genres): #initialize genreList # genre : [(3, 800), (0, 500), (2, 150)] songArr = genreList.get(genre, []) songArr.append((i, plays[i])) genreList[genre] = songArr #initialzie genreSum # genre : 1450, genre2 : 3100 ... genreSum[genre] = genreSum.get(genre, 0) + plays[i] #sort genreList for lst in genreList.values(): lst.sort(key=lambda x: -x[1]) #sort genre sum queue = [] for genre in genreSum: queue.</description></item></channel></rss>