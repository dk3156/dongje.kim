<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>dongje kim
|
자바 스프링 튜토리얼
</title><meta charset=utf-8><meta name=generator content="Hugo 0.120.2"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="dongje kim"><meta name=description content="Portfolio"><link rel=stylesheet href=/dongje.kim/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/dongje.kim/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/dongje.kim/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/dongje.kim/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/dongje.kim/favicon-16x16.png><link rel=canonical href=https://dk3156.github.io/dongje.kim/blog/javaspring/subfolder/springtutorial/><script type=text/javascript src=/dongje.kim/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script><script type=text/javascript src=/dongje.kim/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="자바 스프링 튜토리얼"><meta name=twitter:description content="데이터 베이스 테이블과 자바 클래스를 매핑하는법 spring-boot-starter-data-jpa 의존성을 추가하고 @Entity 어노테이션을 붙여서 매핑한다.
@RequestBody, @ResponseBody JSON 형식의 데이터를 받기 위해 클라이언트에서 요청할 때 JSON -> Java Object 변환이 필요하다. 서버에서도 Java Object -> JSON 변환해서 보내줘야 한다.
@ResponseBody -> 자바 객체를 JSON 내용으로 매핑한다. return type에 맡는 message Converter 를 통해 리턴하는 객체를 해당 타입으로 변환해서 클라이언트로 전달한다.
request body = { &#34;id&#34;:&#34;test0101&#34; &#34;email&#34;:&#34;test@gmail.com&#34; } public class Member { private String id; private String email; } 이와 같이 바디를 클래스 객체로 변환 시킨다."><meta property="og:title" content="자바 스프링 튜토리얼"><meta property="og:description" content="데이터 베이스 테이블과 자바 클래스를 매핑하는법 spring-boot-starter-data-jpa 의존성을 추가하고 @Entity 어노테이션을 붙여서 매핑한다.
@RequestBody, @ResponseBody JSON 형식의 데이터를 받기 위해 클라이언트에서 요청할 때 JSON -> Java Object 변환이 필요하다. 서버에서도 Java Object -> JSON 변환해서 보내줘야 한다.
@ResponseBody -> 자바 객체를 JSON 내용으로 매핑한다. return type에 맡는 message Converter 를 통해 리턴하는 객체를 해당 타입으로 변환해서 클라이언트로 전달한다.
request body = { &#34;id&#34;:&#34;test0101&#34; &#34;email&#34;:&#34;test@gmail.com&#34; } public class Member { private String id; private String email; } 이와 같이 바디를 클래스 객체로 변환 시킨다."><meta property="og:type" content="article"><meta property="og:url" content="https://dk3156.github.io/dongje.kim/blog/javaspring/subfolder/springtutorial/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-30T00:00:00+00:00"><meta property="og:site_name" content="Dongje Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"자바 스프링 튜토리얼","headline":"자바 스프링 튜토리얼","alternativeHeadline":"","description":"
      
        데이터 베이스 테이블과 자바 클래스를 매핑하는법 spring-boot-starter-data-jpa 의존성을 추가하고 @Entity 어노테이션을 붙여서 매핑한다.\n@RequestBody, @ResponseBody JSON 형식의 데이터를 받기 위해 클라이언트에서 요청할 때 JSON -\u0026gt; Java Object 변환이 필요하다. 서버에서도 Java Object -\u0026gt; JSON 변환해서 보내줘야 한다.\n@ResponseBody -\u0026gt; 자바 객체를 JSON 내용으로 매핑한다. return type에 맡는 message Converter 를 통해 리턴하는 객체를 해당 타입으로 변환해서 클라이언트로 전달한다.\nrequest body = { \u0026#34;id\u0026#34;:\u0026#34;test0101\u0026#34; \u0026#34;email\u0026#34;:\u0026#34;test@gmail.com\u0026#34; } public class Member { private String id; private String email; } 이와 같이 바디를 클래스 객체로 변환 시킨다.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/dk3156.github.io\/dongje.kim\/blog\/javaspring\/subfolder\/springtutorial\/"},"author":{"@type":"Person","name":"dongje kim"},"creator":{"@type":"Person","name":"dongje kim"},"accountablePerson":{"@type":"Person","name":"dongje kim"},"copyrightHolder":{"@type":"Person","name":"dongje kim"},"copyrightYear":"2023","dateCreated":"2023-10-30T00:00:00.00Z","datePublished":"2023-10-30T00:00:00.00Z","dateModified":"2023-10-30T00:00:00.00Z","publisher":{"@type":"Organization","name":"dongje kim","url":"https://dk3156.github.io/dongje.kim/","logo":{"@type":"ImageObject","url":"https:\/\/dk3156.github.io\/dongje.kim\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/dk3156.github.io\/dongje.kim\/blog\/javaspring\/subfolder\/springtutorial\/","wordCount":"597","genre":[],"keywords":[]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/dongje.kim/images/tiger.png alt="profile picture"><div class=sidebar__introduction-title><a href=/dongje.kim>Dongje Kim</a></div><div class=sidebar__introduction-description><p>Portfolio</p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/dongje.kim/ title>Home</a></li><li class=nav__list-item><a href=/dongje.kim/experience/work/ title>experience</a></li><li class=nav__list-item><a href=/dongje.kim/projects/ title>project</a></li><li class=nav__list-item><a href=/dongje.kim/blog/ title>blog</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>자바 스프링 튜토리얼</h1><h3 id=데이터-베이스-테이블과-자바-클래스를-매핑하는법>데이터 베이스 테이블과 자바 클래스를 매핑하는법</h3><p>spring-boot-starter-data-jpa 의존성을 추가하고 @Entity 어노테이션을 붙여서 매핑한다.</p><h3 id=requestbody-responsebody>@RequestBody, @ResponseBody</h3><p>JSON 형식의 데이터를 받기 위해 클라이언트에서 요청할 때 JSON -> Java Object 변환이 필요하다. 서버에서도 Java Object -> JSON 변환해서 보내줘야 한다.</p><p>@ResponseBody -> 자바 객체를 JSON 내용으로 매핑한다. return type에 맡는 message Converter 를 통해 리턴하는 객체를 해당 타입으로 변환해서 클라이언트로 전달한다.</p><pre tabindex=0><code>request body = 
{
    &#34;id&#34;:&#34;test0101&#34;
    &#34;email&#34;:&#34;test@gmail.com&#34;
}

public class Member {
    private String id;
    private String email;
}
</code></pre><p>이와 같이 바디를 클래스 객체로 변환 시킨다.</p><h3 id=restcontroller>@RestController</h3><p>http 관련된 코드 밑 요청/응답 매핑을 스프링이 알아서 해준다. @Controller + @ResponseBody 가 합쳐진 형태로 JSON 형태의 객체 데이터를 반환한다.</p><p>클라이언트에서 리소스 get 요청 -> 자바 서버에서 requestMapping 이 페이지 주소를 http 메서드와 매핑한다.</p><h3 id=getmapping>@GetMapping</h3><p>Get 요청 방식의 API를 만들때, @RequestMapping(method = RequestMethod.GET) 방식도 있지만, @GetMapping 을 이용하는 방법도 있다. 아래 예시를 보자.</p><pre tabindex=0><code>@RestController
@RestMapping(&#34;api&#34;)
public class GetController {
    ...
    @GetMapping(&#34;/getParam&#34;)
    public String getParameter(@RequestParam String id, @RequestParam(name = &#34;password&#34;) String pwd){
        return &#34;ID:&#34; + id + &#34;,Password:&#34; + pwd;
    }
}
</code></pre><p>기본적으로 인자 변수명을 파라미터명으로 받는다. 하지만, @RequestParam(name = &ldquo;원하는 파라미터 명&rdquo;)을 이용하면, 파라미터명을 바꿀 수 있다.</p><p>주소가 /api/getParam?id=블라블라 일때@RequestParam String id 의 값은 블라블라이다.</p><p>주소가 /api/getParam?password=블라블라 일때 @RequestParam(name = &ldquo;password&rdquo;) String pwd 의 값은 블라블라.</p><p>파라미터가 많아진다면 VO (value object) 객체를 생성하여 받을 수도 있다. 우선 VO 객체를 생성한다. 그래고 생성한 객체를 아래와 같이 파라미터값으로 넣어준다.</p><pre tabindex=0><code>@GetMapping(&#34;/getMultiParam&#34;)
public String getMultiParameter(VO_name vo){
    return vo.toString();
}
</code></pre><p>위에서는 계속 문자열을 반환했지만, 요즘 API는 대부분 JSON 형식을 사용한다.</p><pre tabindex=0><code>@GetMapping(&#34;/returnJson&#34;)
public SearchParamVO returnJson (SearchParamVO vo){
    return vo;
    //{&#34;username&#34;: &#34;tester&#34;,
        &#34;email&#34;:&#34;tester@google.com&#34;,
        &#34;page&#34;:1}
}
</code></pre><p>@RestController 를 이용하면, 내부적으로 Jackson 라이브러리에 의해 VO 객체를 JSON 형태로 변환하여 응답해준다. 만약 @RestController가 아닌 @Controller를 사용한다면, @ResponseBody를 추가해줘야한다.</p><h3 id=예제---spring-으로-간단한-restful-웹-서비스-만들기>예제 - Spring 으로 간단한 RESTful 웹 서비스 만들기</h3><p>Greeting 이라는 리소스 표현 클래스를 만들어서 id 와 클래스 데이터를 view 에 렌더링하는 것을 목적으로 한다.</p><pre tabindex=0><code>package com.example.restservice;
public record Greeting(long id, String content){}
</code></pre><p>Jackson JSON 라이브러리를 사용해 객체를 JSON 으로 자동 매핑해준다.</p><p>다음으로 리소스 컨트롤러를 생성한다. 웹 서비스 http 요청은 컨트롤러에 의해 처리된다. @RestController 어노테이션은 이와같은 컨트롤러를 지칭.</p><pre tabindex=0><code>@RestController
public class GreetingController{
    private static final String template = &#34;Hello, %s!&#34;;
    private final AtomicLong counter = new AtomicLong();

    @GetMapping(&#34;/greeting&#34;)
    public Greeting greeting(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World) String name){
        return new Greeting(counter.incrementAndGet(), String.format(template, name));
    }
}
</code></pre><p>AtomicLong() 클래스는 Long 타입의 객체를 생성한다. 여기서는 id를 만들기 위해 씀.</p><p>전통적인 MVC 컨트롤러와 Restful web service 컨트롤러의 차이는 HTTP 응답 바디가 생성되는 방식에 있다. 서버 사이드 렌더링을 view에게 맡기는게 아니라 데이터를 객체로 만들고, 그 데이터는 JSON 형식으로 응답 바디로 보내진다.</p><p>코드의 메인 메서드는 Spring Boot의 SpringApplication.run() 메서드를 사용해 프로그램을 실행한다.</p><h3 id=spring-boot>Spring Boot</h3><p>Spring boot를 사용하면 빠르게 웹 어플리케이션을 만들수 있다. 이미 configure된 classpath 와 bean 을 저장한다. 저장할때 뭔가 빠졌으면 spring boot가 알아서 빠진걸 보충해준다. 인프라에 신경쓰지 않고 비즈니스 로직에 집중할 수 있다. 코드를 써주거나 파일을 써주는게 아니라, 어플리케이션을 시작할때 bean 과 setting 을 연결시켜서 어플리케이션 context 에 적용시킨다.</p><p>Spring boot 에서는 다른 서버의 API endpoint 를 호출할때 Rest Template을 많이 쓴다. CRUD Operation(get, post, delete, put)을 처리할때 쓰는 객체이다. 빈 설정을 먼저 해줘야 한다. build()를 사용해 만들어준다.</p><pre tabindex=0><code>@Bean
public RestTemplate restTemplate(RestTemplate Builder builder){
    return builder.build();
}

@Bean
@Profile(&#34;!test&#34;)
public CommandLineRunner run(RestTamplate restTemplate) thorws Exception{
    return args -&gt; {
        Quote quote = restTemplate.getForObject(&#34;http://localhost:8080/api/ramdom&#34;, Quote.class);
        log.info(quote.toString());
    }
}
</code></pre><p>예제에서 CommandLinerRunner 는 구동 시점에 실행되는 코드가 arg 값을 써야할때 쓰는 인터페이스다. 프로그램이 실행되면서 api/random 주소에서 JSON 응답을 가져온다. 가져온 응답은 Quote 객체에 매핑된다.</p><p>Spring boot 에서 로그 사용시 두가지 방법이 있는데, LoggerFactory로 Logger를 사용하는 방법과 lombok를 쓸 경우 @Slf4j 어노테이션을 넣고 Logger를 사용할 수 있다.</p><p>먼저 LoggerFactory를 사용하는 경우에는Logger log = LoggerFactory.getLogger(class명.class) 이렇게 사용해주면 되고</p><p>lombok을 사용할 경우에는 훨씬 간단하게 클래스명 위에 @Slf4j 어노테이션을 입력한 후 log.메소드명(..); 이런 식으로 사용해주면 된다</p></div><div class=post__footer></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>