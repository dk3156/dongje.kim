<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head><title>dongje kim
|
JVM
</title><meta charset=utf-8><meta name=generator content="Hugo 0.121.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="dongje kim"><meta name=description content="Portfolio"><link rel=stylesheet href=/dongje.kim/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/dongje.kim/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/dongje.kim/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/dongje.kim/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/dongje.kim/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/dongje.kim/favicon-16x16.png><link rel=canonical href=https://dk3156.github.io/dongje.kim/blog/java/subfolder/jvm/><script type=text/javascript src=/dongje.kim/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script><script type=text/javascript src=/dongje.kim/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM"><meta name=twitter:description content="JVM java handbook 을 통해 배운내용!
Chapter에서 알아보기로 한 C언어와 Java의 차이점을 확인해보겠습니다. Java는 Write Once Use Anywhere 이라는 목적을 가지고 있습니다! 번역하자면, &ldquo;소스파일을 하나만 작성하면 어디에서든지 사용이 가능하다!&rdquo; 입니다. 결론, 우리는 Java를 사용하여 기계의 기종별 즉, 운영체제에 구애받지 않고 개발을 할 수 있게 되었습니다. 여기서 Java의 목적파일은 반기계어인 바이트코드(.class) 인데 이는 운영체제가 아니라 JVM에서 사용됩니다. 소스코드를 바이트 코드로 컴파일 해주는게 자바 컴파일러(javac)입니다.
그럼 다음으로 Java가 어떤 과정을 통해 컴파일되어 실행되는지 보겠습니다."><meta property="og:title" content="JVM"><meta property="og:description" content="JVM java handbook 을 통해 배운내용!
Chapter에서 알아보기로 한 C언어와 Java의 차이점을 확인해보겠습니다. Java는 Write Once Use Anywhere 이라는 목적을 가지고 있습니다! 번역하자면, &ldquo;소스파일을 하나만 작성하면 어디에서든지 사용이 가능하다!&rdquo; 입니다. 결론, 우리는 Java를 사용하여 기계의 기종별 즉, 운영체제에 구애받지 않고 개발을 할 수 있게 되었습니다. 여기서 Java의 목적파일은 반기계어인 바이트코드(.class) 인데 이는 운영체제가 아니라 JVM에서 사용됩니다. 소스코드를 바이트 코드로 컴파일 해주는게 자바 컴파일러(javac)입니다.
그럼 다음으로 Java가 어떤 과정을 통해 컴파일되어 실행되는지 보겠습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://dk3156.github.io/dongje.kim/blog/java/subfolder/jvm/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-11-27T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-27T00:00:00+00:00"><meta property="og:site_name" content="Dongje Kim"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blog","name":"JVM","headline":"JVM","alternativeHeadline":"","description":"
      
        JVM java handbook 을 통해 배운내용!\nChapter에서 알아보기로 한 C언어와 Java의 차이점을 확인해보겠습니다. Java는 Write Once Use Anywhere 이라는 목적을 가지고 있습니다! 번역하자면, \u0026ldquo;소스파일을 하나만 작성하면 어디에서든지 사용이 가능하다!\u0026rdquo; 입니다. 결론, 우리는 Java를 사용하여 기계의 기종별 즉, 운영체제에 구애받지 않고 개발을 할 수 있게 되었습니다. 여기서 Java의 목적파일은 반기계어인 바이트코드(.class) 인데 이는 운영체제가 아니라 JVM에서 사용됩니다. 소스코드를 바이트 코드로 컴파일 해주는게 자바 컴파일러(javac)입니다.\n그럼 다음으로 Java가 어떤 과정을 통해 컴파일되어 실행되는지 보겠습니다.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/dk3156.github.io\/dongje.kim\/blog\/java\/subfolder\/jvm\/"},"author":{"@type":"Person","name":"dongje kim"},"creator":{"@type":"Person","name":"dongje kim"},"accountablePerson":{"@type":"Person","name":"dongje kim"},"copyrightHolder":{"@type":"Person","name":"dongje kim"},"copyrightYear":"2023","dateCreated":"2023-11-27T00:00:00.00Z","datePublished":"2023-11-27T00:00:00.00Z","dateModified":"2023-11-27T00:00:00.00Z","publisher":{"@type":"Organization","name":"dongje kim","url":"https://dk3156.github.io/dongje.kim/","logo":{"@type":"ImageObject","url":"https:\/\/dk3156.github.io\/dongje.kim\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/dk3156.github.io\/dongje.kim\/blog\/java\/subfolder\/jvm\/","wordCount":"722","genre":[],"keywords":[]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/dongje.kim/images/tiger.png alt="profile picture"><div class=sidebar__introduction-title><a href=/dongje.kim>Dongje Kim</a></div><div class=sidebar__introduction-description><p>Portfolio</p></div></div><ul class=sidebar__list></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/dongje.kim/ title>Home</a></li><li class=nav__list-item><a href=/dongje.kim/experience/work/ title>experience</a></li><li class=nav__list-item><a href=/dongje.kim/projects/ title>project</a></li><li class=nav__list-item><a href=/dongje.kim/blog/ title>blog</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>JVM</h1><h2 id=jvm>JVM</h2><p>java handbook 을 통해 배운내용!</p><p>Chapter에서 알아보기로 한 C언어와 Java의 차이점을 확인해보겠습니다.
Java는 Write Once Use Anywhere 이라는 목적을 가지고 있습니다!
번역하자면, &ldquo;소스파일을 하나만 작성하면 어디에서든지 사용이 가능하다!&rdquo; 입니다.
결론, 우리는 Java를 사용하여 기계의 기종별 즉, 운영체제에 구애받지 않고 개발을 할 수 있게 되었습니다.
여기서 Java의 목적파일은 반기계어인 바이트코드(.class) 인데 이는 운영체제가 아니라 JVM에서 사용됩니다.
소스코드를 바이트 코드로 컴파일 해주는게 자바 컴파일러(javac)입니다.</p><p>그럼 다음으로 Java가 어떤 과정을 통해 컴파일되어 실행되는지 보겠습니다.</p><p>Java의 실행 과정
개발자는 자바 소스파일(.java)를 작성합니다.
JDK가 제공하는 javac를 사용하여 소스파일을 컴파일합니다.
JVM의 Class Loader는 컴파일로 생성된 바이트 코드(.class)를 전달 받아 동적 로딩을 통해 실행에 필요한 클래스들을 로딩하여 JVM 내부 Runtime Data Area에 로드합니다.
JVM의 Execution에 의해 기계어로 해석되어 실행됩니다.
Class Loader
프로그램 상의 작성한 모든 클래스, 변수 및 메서드의 정보를 Method Area에 배치합니다.
JVM 내부에 바이트 코드를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈입니다.
실행될 때 동적으로 클래스를 로드하고 jar 파일 내부에 저장되어 있는 클래스들을 JVM에 로드합니다.
static(정적) 변수와 메서드는 Heap Area에 배치합니다.
Execution(실행 엔진)
Interpreter는 바이트 코드를 한줄 씩 읽고 번역해 주는데 느리다는 단점이 존재합니다.
그래서 이를 보완하기 위해 나온 것이 JIT 컴파일러입니다.
JIT 컴파일러는 Interpreter 방식으로 실행을 하다가 적당한 시점에 바이트 코드 전체를 컴파일하여 캐싱합니다.
캐싱 즉, 컴파일된 코드를 저장해 두기 때문에 이 코드들은 Interpreter를 통해 실행되는 것이 아니라 바로 실행이 됩니다. 그렇기 때문에 실행 속도가 매우 빨라집니다.
Garbage Collector는 간단하게 설명 하자면 유효하지 않은 즉, 사용되지 않는 메모리를 추적하여 비워주는 기능을 가지고 있습니다.
추가로 인터프리터 언어와 컴파일 언어에 대해 한번 정리하고 가겠습니다.
Compile 언어와 Interpreter 언어</p><p>Compile 언어
소스파일 전체를 컴파일 한 후 기계어를 CPU와 메모리를 통해 읽어서 바로 실행하는 방식으로 동작이 되는 언어
종류 : C, C++, Java, C# &mldr;
특징
소스파일의 크기가 크면 컴파일 과정이 오래 걸릴 수 있습니다.
컴파일이 된 후에 기계어로 바로 실행되기 때문에 실행 속도가 빠릅니다.
Java는 javac에 의해 바이트코드로 컴파일 되지만 JVM에서는 인터프리터로 실행됩니다. 그러므로 Compile 언어이지만, Interpreter 언어의 특징을 동시에 가집니다.</p><p>Interpreter 언어
소스파일을 컴파일하지 않고서 Interpreter를 사용하여 소스파일을 한줄 씩 번역하면서 실행하는 방식으로 동작이 되는 언어
Interpreter : 소스 코드를 바로 번역하여 실행하는 프로그램 혹은 환경
종류 : Javascript, Ruby, Python &mldr;
특징
컴파일 언어처럼 별도의 목적파일이 존재하지 않습니다.
컴파일 과정 없이 바로 실행되기 때문에 수정 및 디버깅시 편합니다.
Interpreter 만 존재하면 어디서든지 실행이 가능하기 때문에 자유롭고 독립적 입니다.
실시간으로 번역 되면서 실행되기 때문에 실행 속도가 느립니다.
JVM
JVM은 Java 프로그램이 실행되는 가상 컴퓨터라고 생각하시면 됩니다.</p><p>위 이미지 처럼 JVM은 내부적으로 복잡한 구조를 가지고 있습니다!
우리는 이 중에서 Runtime Data Areas를 간단하게 정리해 보겠습니다.(Java 8 이후 기준)</p><p>전 처리 과정 이해하기
Runtime Data Areas를 학습하기 전에 전 처리 과정에 대해 학습하겠습니다.
위에서 JRE는 Java의 실행 환경이라고 배웠습니다.
JRE는 프로그램을 실행하기 전에 먼저 프로그램에 메인 메서드를 포함하고 있는지 확인하고 존재한다면 JVM을 부팅시킵니다.
부팅이된 JVM은 전달받은 코드를 실행 시키는데 이때 가장 먼저 하는 일이 전 처리라고 하는 과정입니다.
전 처리 과정
모든 Java 프로그램은 반드시 java.lang 패키지를 포함합니다. 따라서 JRE는 해당 패키지를 Method Area에 배치합니다.
프로그램이 사용하기위해 import한 패키지들도 존재할 겁니다. 마찬가지로 Method Area에 배치합니다.
프로그램 상의 작성한 모든 클래스, 변수 및 메서드의 정보를 Method Area에 배치합니다.
static(정적) 변수와 메서드는 Heap Area에 배치합니다.
Runtime Data Areas
컴퓨터에서 메모리 같은 역할을 수행하는 영역입니다. 자바 프로그램을 실행하여 발생하는 데이터를 저장하는 역할을 하는데, 데이터의 속성에 따라 영역이 분리되어 있습니다.
PC Register
스레드가 시작될 때마다 생성되는 공간으로, 스레드마다 하나씩 존재합니다.
스레드가 어떤 명령에 의해 실행되어야 할지에 대한 기록을 하는 부분으로 현재 수행을 하고 있는 JVM의 명령 주소를 갖고 있습니다.
Native Method Stack
자바 프로그램이 컴파일 되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다.
자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 코드를 실행할 때, Native Method Stack이 할당 되며, 일반적인 C 스택을 사용합니다.
Java Native Interface를 통해 바이트 코드로 전환하여 저장됩니다.
일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역입니다.
Method Area(Metaspace, Static Area, Class Area)
클래스 정보를 처음 메모리 공간에 올릴 때 초기화 되는 대상을 저장하기 위한 공간입니다.
클래스의 타입, 변수 및 메서드등의 정보를 가지고 있으며 모든 Thread가 공유합니다.
Runtime Constant Pool
상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행합니다.
Heap Area</p><p>프로그램 실행 과정에서 임시로 할당이 되었다가 메서드를 빠져나가면 바로 소멸이 되는 특성의 데이터들을 저장하기 위한 영역입니다.
실행되는 메서드 및 중괄호 블록(if문등)에 대한 데이터가 저장되는 영역입니다.
가장 처음 실행되는 메서드(main())가 첫 번째로 메모리에 올라가고 그 다음에 실행되는 메서드들이 위에 쌓이는 구조입니다.
쌓이는 메서드의 단위를 스택 프레임이라고 부릅니다.
해당 메서드를 실행하기 위한 변수 및 블록이 존재하면 스택 프레임 내부에 스택 프레임이 생길 수 있습니다.
가장 큰 특징은 멀티 스레드 환경에서 각 스레드가 고유의 스택 영역을 가진다는 점입니다.</p></div><div class=post__footer></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>@
djkim0424@gmail.com</li></ul></footer><script type=text/javascript src=/dongje.kim/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>