<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>자바 on DONGJE KIM</title><link>https://dk3156.github.io/dongje.kim/blog/java/</link><description>Recent content in 자바 on DONGJE KIM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 03 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dk3156.github.io/dongje.kim/blog/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Handbook</title><link>https://dk3156.github.io/dongje.kim/blog/java/subfolder/javahandbook/</link><pubDate>Mon, 27 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/java/subfolder/javahandbook/</guid><description>문자와 숫자간의 변환 숫자를 문자로 숫자 + &amp;lsquo;0&amp;rsquo; -&amp;gt; 문자 문자를 숫자로 문자 - &amp;lsquo;0&amp;rsquo; -&amp;gt; 숫자
문자열로의 변환 숫자를 문자열로 숫자 + &amp;quot;&amp;quot; -&amp;gt; 문자열 문자를 문자열로 문자 + &amp;quot;&amp;quot; -&amp;gt; 문자열
class Variable4_2 { public static void main(String[] args) { String s1 = &amp;#34;A&amp;#34; + &amp;#34;B&amp;#34;; // &amp;#34;AB&amp;#34; System.out.println(&amp;#34;s1 = &amp;#34; + s1); // 문자열은 문자열하고만 결합할 수 있기 때문에 // 숫자를 문자열로 바꾼 다음에 결합 합니다. String s2 = &amp;#34;&amp;#34; + 7; // &amp;#34;&amp;#34; + 7 =&amp;gt; &amp;#34;&amp;#34; + &amp;#34;7&amp;#34; = &amp;#34;7&amp;#34; System.</description></item><item><title>JVM</title><link>https://dk3156.github.io/dongje.kim/blog/java/subfolder/jvm/</link><pubDate>Mon, 27 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/java/subfolder/jvm/</guid><description>JVM java handbook 을 통해 배운내용!
Chapter에서 알아보기로 한 C언어와 Java의 차이점을 확인해보겠습니다. Java는 Write Once Use Anywhere 이라는 목적을 가지고 있습니다! 번역하자면, &amp;ldquo;소스파일을 하나만 작성하면 어디에서든지 사용이 가능하다!&amp;rdquo; 입니다. 결론, 우리는 Java를 사용하여 기계의 기종별 즉, 운영체제에 구애받지 않고 개발을 할 수 있게 되었습니다. 여기서 Java의 목적파일은 반기계어인 바이트코드(.class) 인데 이는 운영체제가 아니라 JVM에서 사용됩니다. 소스코드를 바이트 코드로 컴파일 해주는게 자바 컴파일러(javac)입니다.
그럼 다음으로 Java가 어떤 과정을 통해 컴파일되어 실행되는지 보겠습니다.</description></item><item><title>자바 문법</title><link>https://dk3156.github.io/dongje.kim/blog/java/subfolder/grammar/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/java/subfolder/grammar/</guid><description>For Coding Test import java.util.HashMap import java.util.Array
System.out.println();
public String function(String[] parameter 1, String[] parameter 2){ return something; } HashMap&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(String player : participant) map.put(player, map.getOrDefault(player, 0) + 1) map. getOrDefault(elem, count)
메소드 기록. if elem in map, bring that value and put it in. if elem not in map, then put the count (default value)
string array of string arrasy String[][] arrays = new String[][] { array1, array2, array3, array4, array5 }; Java ArrayList add(element), get(index), remove(index), remove(element), contains(element) → return boolean</description></item><item><title>자바에서 자주 보이는 Static 이란 무엇일까?</title><link>https://dk3156.github.io/dongje.kim/blog/java/subfolder/static/</link><pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate><guid>https://dk3156.github.io/dongje.kim/blog/java/subfolder/static/</guid><description>https://honbabzone.com/java/java-static/ 참고.
JVM 메모리 구조 Java Virtual Machine 은
Garabage Collector Execution Engine Class Loader Runtime Data Area 4가지 영역으로 나누어지고 이중 Runtime Data Area에 스태틱 변수가 관련이 있다. 데이터 에리어는 메서드, 힙, 스택, PC레지스터, Native 메서드 스택 5가지로 구분되는데 이 중 Method Area 에 static 변수가 있다. 로드된 후 메모리에 항상 상주하고 있는 영역이다. 클래스로더가 static 키워드를 보는 순간 객체가 생성되지 않아도 항상 메모리를 할당해야 하는 멤버로 보고 Method Area 에 메모리를 할당한다.</description></item></channel></rss>