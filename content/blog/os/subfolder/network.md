---
title: "네트워크"
date: 2023-10-31
weight: 2
mainSectionTitle: "hello"
---
대규모 트래픽 처리가 중요한 이유: 잠재적인 고객이 이탈
### 서버가 터지는 이유는?
서버란? 외부로부터 들어오는 요청을 받아 처리해주고 응답을 주는 프로그램이 돌아가고 있는 어느 컴퓨터. 서버또한 처리속도, cpu, 메모리, 저장장치에 영향을 받는다. 

웹 서버라는 프로세스가 있다면 그 프로세스 안에는 다수의 요청을 시분할 처리하는 스레드가 있다. 스레드 수가 많아봐야 결국 task를 처리하는 것은 cpu이기 때문에 속도에 한계가 있다.  요청을 너무 많이 큐에 넣다보면 오버플로우가 발생한다. 메모리 오버플로우가 나면 서버가 종료된다.

해결방안은?

요청을 충분히 빠르게 처리하면 된다. Scale-out 과 Scale-up 방식.

Scale-out: 서버를 물리적으로 늘려버리는 경우다. 업무를 1명이 할때보다 2명, 3명이 하는게 더 빠르다. 서버의 업무를 처리하는 스레드양을 늘린다. 그러나 요청마다 어떤건 많은 처리시간이 필요하고 어떤건 그렇지 않은 경우가 많다. 이때 특정 서버에 처리가 필요한 요청이 쏠릴때, 해당 서버만 터지게 된다.

이는 로드밸런싱으로 문제를 해결한다. 남은 큐의 크기, 축척된 요청의 예상처리 시간등을 고려해 최적의 서버로 요청을 분배해 특정 서버에만 부하 가중을 방지한다. 

Scale-up: 처리하는 하나의 스레드를 더 강하게 만든다. 들어오는 요청 하나를 처리하는 속도를 더 빠르게 만드는 방식. 서버 기억장치의 성능을 향상시켜야 한다. 예를들어 기억장치 HDD에서 SDD로 바꾼다.
*  왜 기억장치를 바꿀까? cpu, 메모리, 기억장치 중 기억장치가 데이터 처리 속도를 규정한다. 기억장치를 통해 데이터를 읽고 쓰는 작업이 필요하다. cpu의 연산 속도가 뛰어나도 기억장치의 I/O 속도가 빠르지 않다면 서버 요청이 쌓일 수 있다. 대규모 트래픽처리를 위한 scale up을 고려하는 경우 기억장치의 I/O 처리 속도의 업그레이드가 필요하다. 

### 캐싱
DB에는 in-memory database라는게 존재한다. 인메모리 데이터의 예로, Redis Memcached가 있다. 대표적인 사용처는 캐싱이다. 반복적으로 요청되는 특정 데이터에 대한 read 비용 감소를 목적으로 한다. 대규모 트래픽 처리에는 캐싱이 매우 중요하다.
인메모리 데이터베이스를 사용하는 경우, 속도는 빨라지지만 메모리를 사용해거 영속성처리를 잘해야 한다. (순간 데이터가 날아갈 수 있음.)

Redis 인메모리 데이터베이스 -> 캐싱을 사용해 기억장치 속도를 높이는 데 쓰는 대표적인 기술. 많은 회사가 Redis를 쓰는 이유는 데이터가 잘 날아가지 않기 때문이다. 또는 DB에 기록하는 부분만 잠시 미루기 위해 메세지 큐를 사용할 수 있다. 예를 들어 Rabbit MQ.  DB에 MQ를 두게 된다면 사용자의 요청에 대한 응답을 넣지 않았지만 넣어질 것이라고 가정한 상태에서 요청을 처리할 수 있다. 실저장 스텝을 감소시켜서 총 처리 시간을 감소한다.

# 네트워킹
## OSI 7계층
네트워크 통신이 일어나는 과정을 7단계로 나눈것이다. (please don't spa)
* physical layer
* datalink layer
* network layer
* transport layer
* session layer
* presentation layer
* application layer

물리계층 -- 전선으로 전기적 신호가 전달되는 계층.

데이터링크 계층 -- 네트워크 기기들 하나하나에 어떻게 통신되는지 알아보는 곳 (데이터 전송 담당)

네트워크 계층 -- 라우터 기능. 경로를 설정하는 곳

전송계층 -- 보낼 데이터의 용량, 속도, 목적지를 처리하는 곳

세션계층 -- 연결이 손실되는 경우 연결 복구를 시도하고 연결을 재개하는 곳. 통신 연결에 관한 계층

표현계층 -- 서로 주고받는 인터페이스를 맞춰주고 규격을 맞춰주는 계층. (jpeg, png 같은 규격)

응용계층 -- 사용자가 쓰는 응용프로그램 계층

### TCP, UDP 
TCP -- 신뢰성이 높은 프로토콜. 3, 4 way handshaking 으로 서버와 클라이언트가 일대일 통신을 하고 흐름제어/혼잡제어가 이루어짐. UDP -- 비연결형 프로토콜. 손상된 데이터를 재전송하지 않고 신뢰성이 낮지만 TCP 보다 속도가 빨라서 스트리밍 서비스에 많이 씀. 1:1, 1:N, 1:M 으로 연결이 가능.

IP: 비신뢰성과 비연결성.
* 비신뢰성 -- 프로토콜일 뿐 보낸 데이터 흐름에 관여하지 않기 때문에 보낸 패킷이 재대로 갔는지 보장하지 않는다. 즉, 순서가 있는 여러개의 데이터를 보냈을 때 받는 데이터가 같은 순서로 받아질 것이란 보장이 될 수 없다. 혹은 중간에 패킷을 가지고 있는 호스트가 강제 종료되어 패킷이 소실될 경우 패킷이 목적지까지 가지 못하고 소실될 수 있다.
* 비연결성 -- 패킷을 받을 대상이 연결 상태임을 확인하지 않고 전송한다. 호스트가 서비스 불능 상태여도 패킷이 전송된다는 문제점이 있다. 
