---
title: "운영체제"
date: 2023-10-31
weight: 3
mainSectionTitle: "hugo"
---
### 운영체제 란?
시스템의 지원과 동작을 관리하는 소프트웨어. 
프로세스, 저장장치, 네트워킹, 사용자, 하드웨어를 관리
과정
사용자 --> 운영체제 --> 주기억장치 / 보조기억장치 --> CPU
사용자가 프로그램 실행을 요청 -> 운영체제가 프로그램 정보를 읽어 메모리에 로드한다. -> cpu는 프로그램을 가져다 메모리를 관리하고 명령물을 실행한다.

### 메모리 구조
Code, Data, Heap, Stack

___

code ---- 소스코드가 들어가는 부분. 실행할 프로그램의 코드가 저장된다. 실행 파일을 구성하는 명령어가 올라간다. (함수, 제어문, 상수)

data ---- global, static 변수가 할당되는 영역. 프로그램 시작과 동시에 할당, 프로그램 종료와 동시에 소멸됨.

heap            ---- runtime. 동적메모리가 할당되면 free store 영역을 사용한다. 위에서 아래로 이동. 클래스같은 동적객체, 프로그래머가 할당/해제하는 공간.

free store

stack          ---- compile time.  스택메모리가 할당되면 free store 영역을 사용한다. 아래에서 위로 이동. 함수 호출 시 local 변수, parameter가 저장된다.

___

heap 과 stack 이 상대 공간을 침범하는 일이 발생할 수 있는데 이것이 heap, stack overflow.

### 프로세스, 스레드
#### 프로세스
프로세스란 컴퓨터에서 연속적으로 실행되고 있는 프로그램이다. 메모리에 올라와 실행되고 있는 프로그램 인스턴스의 개체 운영체제로 부터 시스템 자원을 할당받는 작업의 단위. 할당받는 시스템 자원의 예로 cpu 시간, 운영되기 위해 필요한 주소공간, 독립된 메모리 영역이 있다.

특징: 프로세스는 각각 독립된 메모리 영역을 할당받는다. 기본적으로 최소 1개의 스레드를 가지고 있다. 각 프로세스의 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수, 자료 구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 프로세스간 통신을 사용해야 한다. i.e. 파이프, 파일, 소켓을 사용한 통신 방법.

#### 스레드
프로세스 내에서 실행되는 여러 흐름의 단위. 특정한 수행 경로, 할당받은 자원을 이용하는 실행의 단위이다. 
스레드는 프로세스 내에서 stack 만 할당을 받고 code, data, heap 은 공유한다. 프로세스내의 여러 실행의 흐름으로 프로세스 내 주소 공간이나 자원 (heap space) 을 같은 프로세스내 스레드끼리 공유한다. 

자바스레드 -- 자바에는 프로세스 존재가 없고 스레드만 존재하며, 자바 스레드는 JVM 에 의해 스케쥴되는 실행 단위 코드 블록이다. 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청한다.

#### 멀티프로세스
하나의 응용프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 것을 말한다.
장점: 여러개의 자식 프로세스 중 하나의 문제가 발생하면 자식 프로세스만 죽는 것으로 끝나고 다른 영향이 확산되지 않는다.
단점: Context Switching 과정에서 캐시 메모리의 초기화, 시간 소모, 오버헤드가 발생한다. 

Context Switching - 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태 context 를 보관하고 다음 순서의 프로세스가 동작하면서 이전에 보관했던 상태를 복구하는 작업. (idle / executing)

#### 멀티스레드
하나의 응용 프로그램을 여러개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하는 것. 윈도우, Linux가 멀티스레딩을 기본으로 하고있다. 웹 서버는 대표적인 멀티스레드 응용 프로그램이다. 

장점: 시스템 자원 소모 감소 --> 효율성 증가. 시스템 처리량 증가 --> 처리비용 감소. 스레드간 데이터를 주고 받는 것이 간단해지고 시스템의 자원소모가 줄어들게 된다. 스레드간 작업량이 작아 Context Switching 이 빠르다.
간단한 통신 방법으로 인한 프로그램 응답 시간이 단축된다. 프로세스 내 스택영역을 제외한 메모리 공유로 통신의 부담이 적다.
단점:  디버깅이 까다롭다. 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

### CPU 스케쥴러
준비큐에 있는 프로세스에 cpu를 할당하는 방법. 다음에 실행될 프로세스를 정하고, 프로세스를 실행할 상태로 만든다. 
1. Running --> Waiting (I/O request, 자식 프로세스 종료. wait() 요청을 통해 종료.)
2. Running --> Terminate (부모 프로세스의 종료.)
3. Running --> Ready (인터럽트 발생)
4. Waiting --> Ready (I/O 완료)

* No starvation - 각각의 프로세스가 오랜시간동안 cpu 할당 받지 못하는 상황이 없어야 한다.
* Fairness - 프로세스에 공평하게 cpu를 할당한다.
* Balance - Keeping all parts of the system busy.

#### 비선점 스케쥴링
timeslice 가 없는 스케쥴링. CPU를 사용중인 프로세스가 자율적으로 반납하도록 하는 방식. 1, 2 번 시점에 사용한다. 
1. First Come First Served -- 먼저 cpu 요청하는 프로세스를 먼저 처리하는 방식. 
2. Shortest Job First -- Burst Time 이 짧은 프로세스부터 cpu 할당. 버스트 타임이 긴 프로세스는 오랜시간 굶주려야 하므로 No Starvation (각각의 프로세스가 오랜시간동안 cpu할당 받지 못하는 상황)을 어기게 된다. 

#### 선점 스케쥴링
높은 우선순위를 가진 프로세스가 CPU선점. 스케쥴링 알고리즘에 따라 적당한 프로세스에게 CPU 할당. 필요시에는 회수. 3, 4번 시점에 활용. 1, 2에서도 가능.
1. Shortes Remaining Time -- 최단 잔여시간을 우선으로 하는 스케쥴링. 진행중인 프로세스가 있어도, 최단 잔여시간을 위해 sleep 한다.
2. Round Robin -- Time sharing system. 모둔 프로세스가 같은 우선순위를 가지고 time slice 를 기반으로 스케쥴링 한다. Time slice burst 가 일어나면 해당 프로세스는 스케쥴링 큐의 끝으로 이동한다.
3. Priority Scheduling -- 우선순위가 높을 수록 cpu 우선 할당하는 스케쥴링. 우선순위는 시간 제한, 메모리 용량, 프로세스의 중요성, 자원 사용 비용등에 따라 달라질 수 있다. 우선순위가 같은 경우, First come first served. 

#### 가상 메모리
사용하는 부분에만 메모리에 올리고, 나머지는 디스크에 보관하는 것 
물리 메모리 크기의 한계를 극복하기 위해 나온 기술로, 물리 메모리보다 큰 프로세스를 수행하기 위해서 가상메모리를 사용한다. 예를들어 100MB 메모리에서 200MB 프로세스 수행하기. 
--> 필요한 부분만 메모리에 적재한다. 페이지 단위를 사용한다. 현제 필요한 페이지만 메모리에 올리는 것을 Demanding Paging이라고 한다. 기존의 page table과 다른점은 valid bit이 추가된것. 이는 현재 메모리에 페이지가 있는지 없는지 나타내는 비트이다. 현재 메모리에 있다면 1, 없다면 0을 가진다. (cpu에서 p1의 3번째 페이지에 접근하는데 valid bit 이 0일때 cpu에 인터럽트 신호를 발생해서 운영체제 내부에 1SR로 점프한다. 여기서 디스크 내부에 프로세스 p1에 있는 두번째 페이지를 메모리에 할당한다.)

#### 데드락
p1, p2 가 자원 A, B 둘다 얻어야하는 상황일때 p1은 A를 얻고 p2는 B를 얻었다면 두 프로세스는 자원을 무한정 기다리게 되는데 이를 데드락이라 한다. 네가지 조건이 동시에 성립할 때 데드락이 발생한다. 하나라도 성립하지 않으면 데드락이 해결 가능하다. 
* 상호배제- 자원은 한번에 한 프로세스만 가지게 한다..
* 점유대기- 자원을 가지고 있는 프로세스는 다른 프로세스가 가진 자원을 기다린다.
* 비선점 - 다른 프로세스의 자원을 사용이 끝날때 까지 강제로 빼았을 수 없다. 
* 순환대기 - a는 b의 자원을 기다리고 b는 c의 자원을 기다리고 ... z는 a의 자원을 기다려 순환이 만들어진다.

####