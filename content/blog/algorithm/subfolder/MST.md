---
title: "Kruskal"
date: 2023-11-29
mainSectionTitle: "hugo"
---
## 최소 신장 트리를 찾는 크루스칼 알고리즘
크루스칼 알고리즘이란 최소 신장 트리를 찾는 알고리즘으로, 원본 그래프에소 신장 트리를 만들 수 있는 경우의 수들 둥 최소의 간선 비용을 들여서 만들 수 있는 신장트리를 최소 신장 트리라고 한다. 크루스칼 알고리즘은 가장 적은 간선 비용으로 모든 노드를 연결할 수 있는데, 이런 측면에서 그리디 알고리즘으로 분류되기도 한다. 크루스칼 알고리즘의 동작 과정을 단계화시키면 다음과 같다. 

1. 주어진 모든 간선 정보에 대해 간선 비용이 낮은 순서(오름차순)로 정렬을 수행
2. 정렬된 간선 정보를 하나씩 확인 하면서 현재의 간선이 노드들 간의 사이클을 발생시키는지 확인
3. 만약 사이클이 발생하지 않은 경우, 최소 신장 트리에 포함시키고 사이클이 발생한 경우, 최소 신장 트리에 포함시키지 않음
4. 1번~3번의 과정을 모든 간선 정보에 대해 반복 수행

위 단계를 살펴보면 노드들 간의 사이클이 발생하는지 여부에 따라 최소 신장 트리로 포함시킬지 여부를 결정하는 것을 볼 수 있다.노드들 간의 사이클이 발생하는지 야부는 노드들의 부모노드가 같다면 사이클이 발생, 같지 않다 면 사이클이 발생하지 않음을 의미한다. 

![](/static/images/kruskal.png)

이제 아래와 같이 그래프 정보가 주어졌다고 가정했을 때, 최소 신장 트리를 찾는 크루스탈 알고리즘 과정을 단계별로 도식화해서 살펴보자. 초기 단계는 주어진 간선 정보를 오름차순으로 정렬한 이후 상태라고 가정하겠다. 부모테이은 간선 정보를 받기 전에는 자기 자신을 부모노드로 하도록값을 초기화 시킨 상태다. 이제 정렬된 간선 정보에서 앞에 순서대로 하나씩 받아서 처리해보자. 

1. 첫번째 Union 연산

처음 간선 정보는 (3, 4)의 비용이 7이다. 부모 테이블로 가서 3번, 4번 노드의 부모노드를 각각확인한다. 3번, 4번의 부모노드는 현재 각각 자기 자신인 3번, 4번이다. 두 부모노드가 서로 다르다. 사이클이 발생하지 않는다. 그러므로 최소 신장트리에 포함하기로 한다. 또한 노드 번호가 3 < 4 이기 때문에, 부모 테이블의 4번 노드의 부모노드 값을 3으로 바꿔준다. 업데이트 된 내용은 아래와 같다. 

![](/static/images/kruskal2.png)

2. 두번째 union 연산

두번째 간선 정보는 4, 7 의 비용이 13 이다. 부모 테이블로 가서 4번 노드의 부모노드는 3이고 7번 부모노드는 7이라는 걸 확인했다. 두 부모노드가 서로 다르므로 사이클이 발생하지 않는다. 그러므로 최소 신장 트리에 포함시켜준다. 또한 3 < 7 이므로 7번 -> 4번 노드로 연결해주고 부모테이블 7번 노드 값을 3으로 업데이트 해준다. 

...같은 방식으로 모든 간선을 확인한 뒤 업데이트 해준다. 

### 크루스칼 알고리즘을 python 으로 구현하기
크루스칼 알고리즘 소스코드는 서로소 집합 자료구조를 공부할 때 활용한 Union, Find dㅕㄴ산, 사이클 판별 로직을 활용하면 생각보다 간단하게 구현할 수 있다. 
```
import sys
v, e = map(int, input().split())
parent = [0] * (v+1)
for i in range(1, v+1):
    parent[i] = i

def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

edges = []
total_cost = 0

for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b))

edges.sort()

for i in range(e):
    cost, a, b = edges[i]
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        total_cost += cost
        
print(total_cost)
```